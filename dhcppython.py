# coding: utf-8

'''
# Repository

[lvfrazao/dhcppython | Github](https://github.com/lvfrazao/dhcppython)

# License

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2020 Victor Frazao

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
'''

from __future__ import annotations
from typing_extensions import TypedDict

import csv
from abc import ABC, abstractmethod
import collections.abc
from typing import ClassVar, Dict, Union, List, Tuple, Optional
import ipaddress
import struct
import json
import random
import string
import datetime
import socket
import unicodedata
from dataclasses import dataclass

class DHCPException(Exception):
    """
    Base exception for our DHCP functions
    """

class MalformedPacketError(DHCPException):
    """
    The DHCP packet has some sort of issue
    """

class DHCPValueError(DHCPException):
    """
    Something wrong with the DHCP semantics
    """

class DHCPClientError(DHCPException):
    """
    Something went wrong in the DHCP client
    """

"""
Provides set of classes for decoding and encoding DHCP options.
A high level API is provided by the `options` object and the Option class:
1. Create an options object from bytes by calling the `bytes_to_object` method
e.g., 
```
>>> options.bytes_to_object(b'\x3d\x07\x01\x8c\x45\x00\x1d\x48\x16')
ClientIdentifier(code=61, length=7, data=b'\x01\x8cE\x00\x1dH\x16')
```
2. Get a human readable dict of an options object value
```
 >>> ClientIdentifier(code=61, length=7, data=b'\x01\x8cE\x00\x1dH\x16').value
{'client_identifier': {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'}}
>>> options.bytes_to_object(b'\x3d\x07\x01\x8c\x45\x00\x1d\x48\x16').value
{'client_identifier': {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'}}
```
3. Create an options object from its human readable dict of its value:
```
>>> options.value_to_object({'client_identifier': {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'}})
ClientIdentifier(code=61, length=7, data=b'\x01\x8cE\x00\x1dH\x16')
```
4. Convert a human readable dict of an option value to the bytes representation
```
>>> options.value_to_bytes(({'client_identifier': {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'}}))
b'=\x07\x01\x8cE\x00\x1dH\x16'
>>> [int(i) for i in options.value_to_bytes(({'client_identifier': {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'}}))]
[61, 7, 1, 140, 69, 0, 29, 72, 22]
```
5. Get the bytes representation of an option given its Option object
```
>>> ClientIdentifier(code=61, length=7, data=b'\x01\x8cE\x00\x1dH\x16').asbytes
b'=\x07\x01\x8cE\x00\x1dH\x16'
```
6. Create an options object from its code and "short value"
```
>>> options.short_value_to_object(61, {'hwtype': 1, 'hwaddr': '8C:45:00:1D:48:16'})
ClientIdentifier(code=61, length=7, data=b'\x01\x8cE\x00\x1dH\x16')
```
"""

OPTIONS: Dict[int, Dict[str, Union[str, int]]] = {
    int(line[0]): {
        "name": line[1],
        "len": int(line[2]) if line[2].isdigit() else line[2],
        "description": line[3],
        "rfc": line[4].split("RFC")[-1][:-1],
    }
    for line in csv.reader(open(r"files\options.csv", encoding='utf-8').readlines())
    if line[0].isdigit()
}

class CodeDataMapping(TypedDict):
    obj: Option
    index: int

class OptionList(collections.abc.MutableSequence):
    def __init__(self, options_array: Optional[List[Option]] = None):
        self.data: List[Option] = list(options_array) if options_array else []
        self.code_to_data: Dict[int, CodeDataMapping] = {
            opt.code: {"obj": opt, "index": i} for i, opt in enumerate(self.data)
        }
    def __repr__(self):
        return f"OptionList({self.data})"
    def by_code(self, code: int) -> Optional[Option]:
        return self.code_to_data.get(code, {}).get("obj")
    def append(self, item: Option):
        if item.code not in self.code_to_data:
            self.data.append(item)
            self.code_to_data[item.code] = {"obj": item, "index": len(self.data) - 1}
        else:
            self.data[self.code_to_data[item.code]["index"]] = item
            self.code_to_data[item.code]["obj"] = item
    def insert(self, index: int, obj: Option):
        if obj.code in self.code_to_data:
            # delete previous object and insert this one at the specified pos
            del self[self.code_to_data[obj.code]["index"]]
        self.data.insert(index, obj)
        # Re-index entire list...
        for opt in self.code_to_data.values():
            if opt["index"] >= index:
                opt["index"] += 1
        self.code_to_data[obj.code] = {
            "obj": obj,
            "index": index,
        }
    def __len__(self):
        return len(self.data)
    def __getitem__(self, key: int) -> Option:
        return self.data[key]
    def __setitem__(self, key: int, value: Option):
        # Remove entry of option in current index
        for opt in self.code_to_data.values():
            if opt["index"] == key:
                del self.code_to_data[opt["obj"].code]
                break
        # update self.data list with object
        self.data[key] = value
        # reindex the object that is in the list
        self.code_to_data[value.code] = {
            "obj": value,
            "index": key,
        }
        for index, opt in enumerate(self.data):
            if opt.code == value.code and index != key:
                del self[index]
                if index < key:
                    self.code_to_data[value.code] = {
                        "obj": value,
                        "index": key,
                    }
                    break
    def __delitem__(self, key: int):
        code = self.data[key].code
        # problematic cause it reindexes the whole list
        for opt in self.code_to_data.values():
            if opt["index"] > key:
                opt["index"] -= 1
        del self.code_to_data[code]
        del self.data[key]
    def __contains__(self, other):
        if hasattr(other, "asbytes"):
            return other in self.data
        return other in self.code_to_data
    def __eq__(self, other):
        for self_item, other_item in zip(self, other):
            if not (self_item == other_item):
                return False
        return True
    def as_dict(self):
        opt_dict = {}
        for opt in self.data:
            opt_dict.update(opt.value)
        return opt_dict
    @property
    def json(self):
        return json.dumps(self.as_dict(), indent=4)

class OptionDirectory(object):
    def __init__(self):
        self.directory = {}
        self.key_code_map = {}
        temp = dict(globals())
        for obj in temp:
            try:
                cls = globals()[obj]
                code = cls.__dict__["code"]
                key = cls.__dict__["key"]
            except:
                pass
            else:
                self.directory[code] = cls
                self.key_code_map[key] = code
    def value_to_code(self, value: dict) -> int:
        code = self.key_code_map.get(list(value)[0])
        return code
    def code_to_class(self, code: int) -> Option:
        return self.directory.get(code, UnknownOption)
    def value_to_bytes(self, value: dict):
        code = self.value_to_code(value)
        return self.code_to_class(code).from_value(value).asbytes
    def value_to_object(self, value: dict):
        code = self.value_to_code(value)
        return self.code_to_class(code).from_value(value)
    def short_value_to_object(
        self, code: int, short_value: Union[str, int, bool, dict, List[int], List[str]]
    ):
        cls = self.code_to_class(code)
        return cls.from_value({cls.key: short_value})
    def bytes_to_object(self, data: bytes):
        if data[0] in [0, 255]:
            code, length, data = (data[0], 0, b"")
        else:
            code, length, data = struct.unpack(f">BB{len(data) - 2}s", data)
        return self.code_to_class(code)(code, length, data)

class Option(ABC):
    # __slots__ = ("code", "key", "length", "data", "_value", "name", "description") # Probably dont need this right now
    code: int = -1
    key = ""
    def __init__(self, code: int, length: int, data: bytes) -> None:
        global OPTIONS
        # Option code, single byte, values from 0 to 255 are valid
        if code != self.code:
            raise DHCPValueError(f"Option code does not match {code} != {self.code}")
        self.length = (
            length  # Option size (# of bytes), options 0 and 255 are fixed size (0)
        )
        self.data = data  # Option data in bytes
        self._value: Optional[dict] = None
        self.name = OPTIONS.get(self.code, {}).get("name", "Unknown")
        self.description = OPTIONS.get(self.code, {}).get("description", "Unknown")
    def __repr__(self):
        return f"{self.__class__.__name__}(code={self.code}, length={self.length}, data={self.data})"
    def __eq__(self, other):
        return self.asbytes == other.asbytes
    @property
    @abstractmethod
    def value(self):
        """
        DHCP option data in Python dict containing human readable keys and
        values
        """
    @classmethod
    @abstractmethod
    def from_value(cls, value):
        """
        Construct the option class given a dict of option kvps
        """
    @property
    def asbytes(self) -> bytes:
        """
        Wireformat for option including code and length
        """
        return struct.pack(">BB", self.code, self.length) + self.data
    def data2IParray(self) -> List[str]:
        """
        It is common to see lists of IP addrs as option values. This returns a
        list of IPs from the options data.
        """
        num_addrs = len(self.data) // 4
        return [
            str(ipaddress.IPv4Address(ip))
            for ip in struct.unpack(">" + "L" * num_addrs, self.data)
        ]
    def data2string(self) -> str:
        """
        Converts a data field to a string.
        """
        return struct.unpack(f">{len(self.data)}s", self.data)[0].decode().strip()
    def data2bool(self) -> bool:
        """
        Converts data to bool value.
        """
        return struct.unpack(">?", self.data)[0]
    def data2bin(self) -> str:
        """
        Converts data to a string representation of the binary data
        """
        return " ".join([f"0x{d:02X}" for d in self.data])
    def data2IPpairs(self) -> List[Tuple[str, str]]:
        """
        Converts data to tuples of IP pairs.
        """
        num_pairs = len(self.data) // 8
        pairs: List[Tuple[str, str]] = []
        for i in range(num_pairs):
            ip1, ip2 = [
                str(ipaddress.IPv4Address(ip))
                for ip in struct.unpack(">LL", self.data[i * 8 : (i + 1) * 8])
            ]
            pairs.append((ip1, ip2))
        return pairs
    def data2uint8(self) -> int:
        """
        Converts data to unsigned 8 bit integer.
        """
        return struct.unpack(">B", self.data)[0]
    def data2uint16(self) -> int:
        """
        Converts data to unsigned 16 bit integer.
        """
        return struct.unpack(">H", self.data)[0]
    def data2uint32(self) -> int:
        """
        Converts data to unsigned 32 bit integer.
        """
        return struct.unpack(">L", self.data)[0]
    def data2int32(self) -> int:
        """
        Converts data to signed 32 bit integer.
        """
        return struct.unpack(">l", self.data)[0]
    def data2uint8array(self) -> List[int]:
        """
        Converts data to list of unsigned 8 bit integers.
        """
        return list(struct.unpack(">" + "B" * len(self.data), self.data))
    def data2uint16array(self) -> List[int]:
        """
        Converts data to list of unsigned 16 bit integers.
        """
        return list(struct.unpack(">" + "H" * (len(self.data) // 2), self.data))
    @staticmethod
    def IParray2data(value: List[str]) -> bytes:
        """
        Converts list of IP addresses to bytes
        """
        return b"".join([ipaddress.IPv4Address(ip).packed for ip in value])
    @staticmethod
    def int32array2data(value: List[int]) -> bytes:
        """
        Converts list of int32s to bytes
        """
        return struct.pack(">" + "l" * len(value), *value)
    @staticmethod
    def uint8array2data(value: List[int]) -> bytes:
        """
        Converts list of uint8s to bytes
        """
        return struct.pack(">" + "B" * len(value), *value)
    @staticmethod
    def uint16array2data(value: List[int]) -> bytes:
        """
        Converts list of uint16s to bytes
        """
        return struct.pack(">" + "H" * len(value), *value)
    @staticmethod
    def uint32array2data(value: List[int]) -> bytes:
        """
        Converts list of uint32s to bytes
        """
        return struct.pack(">" + "L" * len(value), *value)
    @staticmethod
    def bool2data(value: bool) -> bytes:
        """
        Converts bool to bytes
        """
        return struct.pack(">?", value)
    @staticmethod
    def bin2data(value: str) -> bytes:
        """
        Converts string representing binary data to bytes
        """
        return struct.pack(
            ">" + "B" * len(value.split()), *[int(val[2:], 16) for val in value.split()]
        )

class BinOption(Option):
    """
    Generic implementation of binary option
    """
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {self.key: self.data2bin()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        is_unknown_option = True if cls.code == -1 else False
        if is_unknown_option:
            code = int(list(value)[0].split("_")[1])
            key = list(value)[0]
        else:
            code = cls.code
            key = cls.key
        data = cls.bin2data(value[key])
        return cls(code, len(data), data)

class BoolOption(Option):
    """
    Generic implementation of boolean option
    """
    @property
    def value(self) -> Dict[str, bool]:
        if self._value is None:
            self._value = {self.key: self.data2bool()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, bool]):
        data = cls.bool2data(value[cls.key])
        return cls(cls.code, len(data), data)

class StrOption(Option):
    """
    Generic implementation of string option
    """
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {self.key: self.data2string()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        data = value[cls.key].encode()
        return cls(cls.code, len(data), data)

class IPOption(Option):
    """
    Generic implementation of an IP option
    """
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {self.key: self.data2IParray()[0]}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        data = cls.IParray2data([value[cls.key]])
        return cls(cls.code, len(data), data)

class IPArrayOption(Option):
    """
    Generic implementation of an IP array
    """
    @property
    def value(self) -> Dict[str, List[str]]:
        if self._value is None:
            self._value = {self.key: self.data2IParray()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, List[str]]):
        data = cls.IParray2data(value[cls.key])
        return cls(cls.code, len(data), data)

class uint8Option(Option):
    """
    Generic implementation of an uint8 option
    """
    @property
    def value(self) -> Dict[str, int]:
        if self._value is None:
            self._value = {self.key: self.data2uint8()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, int]):
        data = cls.uint8array2data([value[cls.key]])
        return cls(cls.code, len(data), data)

class uint16Option(Option):
    """
    Generic implementation of an uint16 option
    """
    @property
    def value(self) -> Dict[str, int]:
        if self._value is None:
            self._value = {self.key: self.data2uint16()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, int]):
        data = cls.uint16array2data([value[cls.key]])
        return cls(cls.code, len(data), data)

class uint32Option(Option):
    """
    Generic implementation of an uint32 option
    """
    @property
    def value(self) -> Dict[str, int]:
        if self._value is None:
            self._value = {self.key: self.data2uint32()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, int]):
        data = cls.uint32array2data([value[cls.key]])
        return cls(cls.code, len(data), data)

class uint8ArrayOption(Option):
    """
    Generic implementation of an uint8 array option
    """
    @property
    def value(self) -> Dict[str, List[int]]:
        if self._value is None:
            self._value = {self.key: self.data2uint8array()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, List[int]]):
        data = cls.uint8array2data(value[cls.key])
        return cls(cls.code, len(data), data)

class uint16ArrayOption(Option):
    """
    Generic implementation of an uint16 array option
    """
    @property
    def value(self) -> Dict[str, List[int]]:
        if self._value is None:
            self._value = {self.key: self.data2uint16array()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, List[int]]):
        data = cls.uint16array2data(value[cls.key])
        return cls(cls.code, len(data), data)

class int32Option(Option):
    """
    Generic implementation of an int32 option
    """
    @property
    def value(self) -> Dict[str, int]:
        if self._value is None:
            self._value = {self.key: self.data2int32()}
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, int]):
        data = cls.int32array2data([value[cls.key]])
        return cls(cls.code, len(data), data)

class Pad(Option):
    """
    Option 0
    The pad option can be used to cause subsequent fields to align on word
    boundaries.
    """
    code = 0
    key = "pad_option"
    @property
    def value(self) -> Dict[str, str]:
        return {self.key: ""}
    @classmethod
    def from_value(cls, value: dict):
        return cls(0, 0, b"")
    @property
    def asbytes(self) -> bytes:
        return b"\x00"

class End(Option):
    """
    Option 255
    End
    """
    code = 255
    key = "end_option"
    @property
    def value(self) -> Dict[str, str]:
        return {self.key: ""}
    @classmethod
    def from_value(cls, value: dict):
        return cls(255, 0, b"")
    @property
    def asbytes(self):
        return b"\xff"

class SubnetMask(IPOption):
    """
    Option 1
    Subnet Mask
    If both the subnet mask and the router option are specified in a DHCP
    reply, the subnet mask option MUST be first.
    e.g., 255.255.255.0
    Option value defined as {"subnet_mask": '255.255.255.0'}
    """
    code = 1
    key = "subnet_mask"

class TimeOffset(int32Option):
    """
    Option 2
    Time Offset
    Specifies the offset of the client's subnet in seconds from Coordinated
    Universal Time (UTC).
    e.g., 3600 seconds (+1 hours)
    Option value defined as {"time_offset_s": 3600, "time_offset_h": 1]}
    """
    code = 2
    key = "time_offset_s"

class Router(IPArrayOption):
    """
    Option 3
    Specifies a list of IP addresses for routers on the client's subnet.
    Routers SHOULD be listed in order of preference.
    Minimum length for the router option is 4 octets, and the length MUST
    always be a multiple of 4.
    e.g., 192.168.0.1
    Option value defined as {"routers": ['1.1.1.1', '2.2.2.2']}
    """
    code = 3
    key = "routers"

class TimeServer(IPArrayOption):
    """
    Option 4
    Specifies a list of RFC 868 [6] time servers available to the client.
    Servers SHOULD be listed in order of preference.
    The minimum length for
    this option is 4 octets, and the length MUST always be a multiple of
    4.
    Option value defined as {"time_servers": ['1.1.1.1', ...]}
    """
    code = 4
    key = "time_servers"

class NameServer(IPArrayOption):
    """
    Option 5
    Specifies a list of IEN 116 name servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"name_servers": ['1.1.1.1', ...]}
    """
    code = 5
    key = "name_servers"

class DNSServer(IPArrayOption):
    """
    Option 6
    Specifies a list of Domain Name System (STD 13, RFC 1035) name servers
    available.
    Listed in order, multiple of 4
    Option value defined as {"dns_servers": ['1.1.1.1', ...]}
    """
    code = 6
    key = "dns_servers"

class LogServer(IPArrayOption):
    """
    Option 7
    Specifies a list of MIT-LCS UDP log servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"log_servers": ['1.1.1.1', ...]}
    """
    code = 7
    key = "log_servers"

class CookieServer(IPArrayOption):
    """
    Option 8
    Specifies a list of RFC 865 [9] cookie servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"cookie_servers": ['1.1.1.1', ...]}
    """
    code = 8
    key = "cookie_servers"

class LPRServer(IPArrayOption):
    """
    Option 9
    Specifies a list of RFC 1179 [10] line printer servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"lpr_servers": ['1.1.1.1', ...]}
    """
    code = 9
    key = "lpr_servers"

class ImpressServer(IPArrayOption):
    """
    Option 10
    Specifies a list of Imagen Impress servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"impress_servers": ['1.1.1.1', ...]}
    """
    code = 10
    key = "impress_servers"

class ResourceLocationServer(IPArrayOption):
    """
    Option 11
    Specifies a list of RFC 887 [11] Resource Location servers available to the client.
    Listed in order, multiple of 4
    Option value defined as {"resource_location_servers": ['1.1.1.1', ...]}
    """
    code = 11
    key = "resource_location_servers"

class Hostname(StrOption):
    """
    Option 12
    Specifies the name of the client.  The name may or may not be qualified
    with the local domain name (see section 3.17 for the preferred way to
    retrieve the domain name).  See RFC 1035 for character set restrictions.
    Min len 1
    Option value defined as {"hostname": "laptop01"}
    """
    code = 12
    key = "hostname"

class BootfileSize(uint16Option):
    """
    Option 13
    Specifies the length in 512-octet blocks of the default boot image for
    the client.
    Len 2
    Option value defined as {"bootfile_size": 256}
    """
    code = 13
    key = "bootfile_size"

class MeritDumpFile(StrOption):
    """
    Option 14
    Specifies the path-name of a file to which the client's core image
    should be dumped in the event the client crashes.
    Min len 1
    Option value defined as {"merit_dump_file": "something"}
    """
    code = 14
    key = "merit_dump_file"

class DomainName(StrOption):
    """
    Option 15
    Specifies the domain name that client should use when resolving
    hostnames via the Domain Name System.
    Min len 1
    Option value defined as {"domain_name": "google.com"}
    """
    code = 15
    key = "domain_name"

class SwapServer(IPOption):
    """
    Option 16
    Sspecifies the IP address of the client's swap server.
    Len 4
    Option value defined as {"swap_server": "1.1.1.1"}
    """
    code = 16
    key = "swap_server"

class RootPath(StrOption):
    """
    Option 17
    Specifies the path-name that contains the client's root disk.
    Min len 1
    Option value defined as {"root_path": "something"}
    """
    code = 17
    key = "root_path"

class ExtensionPath(StrOption):
    """
    Option 18
    String to specify a file, retrievable via TFTP, which contains
    information which can be interpreted in the same way as the 64-octet
    vendor-extension field within the BOOTP response.
    Option value defined as {"extensions_path": "something"}
    """
    code = 18
    key = "extensions_path"

class IPForwarding(BoolOption):
    """
    Option 19
    Specifies whether the client should configure its IP layer for packet
    forwarding.
    Option value defined as {"ip_forwarding": True}
    """
    code = 19
    key = "ip_forwarding"

class NonLocalSourceRouting(BoolOption):
    """
    Option 20
    Specifies whether the client should configure its IP layer to allow
    forwarding of datagrams with non-local source routes.
    Option value defined as {"non_local_source_routing": True}
    """
    code = 20
    key = "non_local_source_routing"

class PolicyFilter(Option):
    """
    Option 21
    Specifies policy filters for non-local source routing. The filters
    consist of a list of IP addresses and masks which specify
    destination/mask pairs with which to filter incoming source routes.
    Option value defined as:
    {
        "policy_filters": [{"address": "1.1.1.1", "mask": "255.255.255.0"}, ...]
    }
    """
    code = 21
    key = "policy_filters"
    @property
    def value(self) -> Dict[str, List[Dict[str, str]]]:
        if self._value is None:
            self._value = {
                self.key: [
                    {"address": pair[0], "mask": pair[1]}
                    for pair in self.data2IPpairs()
                ]
            }
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, List[Dict[str, str]]]):
        ip_array: List[str] = []
        for pair in value[cls.key]:
            ip_array.extend(pair.values())
        data = cls.IParray2data(ip_array)
        return cls(cls.code, len(data), data)

class MaxDGRAMReassemblySize(uint16Option):
    """
    Option 22
    Specifies the maximum size datagram that the client should be prepared
    to reassemble.
    Option value defined as {"max_datagram_reassembly_size": 512}
    """
    code = 22
    key = "max_datagram_reassembly_size"

class IPTTL(uint8Option):
    """
    Option 23
    Specifies the default time-to-live that the client should use on
    outgoing datagrams.
    Object value is defined as: {"default_ip_ttl": 123}
    """
    code = 23
    key = "default_ip_ttl"

class PathMTUAgingTimeout(uint32Option):
    """
    Option 24
    Specifies the timeout (in seconds) to use when aging Path MTU values
    discovered by the mechanism defined.
    Len 4
    Object value is defined as: {"path_MTU_aging_timeout":1234}
    """
    code = 24
    key = "path_MTU_aging_timeout"

class PathMTUAgingTable(uint16ArrayOption):
    """
    Option 25
    Specifies a table of MTU sizes to use when performing Path MTU Discovery
    as defined in RFC 1191.
    Object value defined as: {"path_mtu_aging_table": [123, 234, ...]}
    """
    code = 25
    key = "path_mtu_aging_table"

class InterfaceMTU(uint16Option):
    """
    Option 26
    Specifies the MTU to use on this interface.
    Object value defined as: {"interface_mtu": 1234}
    """
    code = 26
    key = "interface_mtu"

class AllSubnetsLocal(BoolOption):
    """
    Option 27
    Specifies whether or not the client may assume that all subnets of the
    IP network to which the client is connected use the same MTU as the
    subnet of that network to which the client is directly connected.
    Option value defined as: {"all_subnets_local": True}
    """
    code = 27
    key = "all_subnets_local"

class BroadcastAddress(IPOption):
    """
    Option 28
    Specifies the broadcast address in use on the client's subnet.
    Objected defined as: {"broadcast_address": "1.1.1.1"}
    """
    code = 28
    key = "broadcast_address"

class PerformMaskDiscovery(BoolOption):
    """
    Option 29
    Specifies whether or not the client should perform subnet mask
    discovery using ICMP.
    Object value defined as: {"perform_mask_discovery"}
    """
    code = 29
    key = "perform_mask_discovery"

class MaskSupplier(BoolOption):
    """
    Option 30
    Specifies whether or not the client should respond to subnet mask
    requests using ICMP.
    Object defined as: {"mask_supplier": True}
    """
    code = 30
    key = "mask_supplier"

class PerformRouterDiscovery(BoolOption):
    """
    Option 31
    Specifies whether or not the client should solicit routers using the
    Router Discovery mechanism defined in RFC 1256 [13].
    Object defined as: {"perform_router_discovery": True}
    """
    code = 31
    key = "perform_router_discovery"

class RouterSolicitationAddress(IPOption):
    """
    Option 32
    Specifies the address to which the client should transmit router
    solicitation requests.
    Option value defined as: {"router_solicitation_address": "1.1.1.1"}
    """
    code = 32
    key = "router_solicitation_address"

class StaticRoute(Option):
    """
    Option 33
    Specifies a list of static routes that the client should install in its
    routing cache. If multiple routes to the same destination are specified,
    they are listed in descending order of priority.
    """
    code = 33
    key = "static_routes"
    @property
    def value(self) -> Dict[str, List[Dict[str, str]]]:
        if self._value is None:
            self._value = {
                self.key: [
                    {"destination": pair[0], "router": pair[1]}
                    for pair in self.data2IPpairs()
                ]
            }
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, List[Dict[str, str]]]):
        ip_array: List[str] = []
        for pair in value[cls.key]:
            ip_array.extend(pair.values())
        data = cls.IParray2data(ip_array)
        return cls(cls.code, len(data), data)

class TrailerEncapsulation(BoolOption):
    """
    Option 34
    Specifies whether or not the client should negotiate the use of trailers
    (RFC 893 [14]) when using the ARP protocol. 
    Option value defined as: {"trailer_encapsulation": True}
    """
    code = 34
    key = "trailer_encapsulation"

class ARPCacheTimeout(uint32Option):
    """
    Option 35
    Specifies the timeout in seconds for ARP cache entries.
    Option value defined as: {"arp_cache_timeout": 123}
    """
    code = 35
    key = "arp_cache_timeout"

class EthernetEncapsulation(BoolOption):
    """
    Option 36
    Specifies whether or not the client should use Ethernet Version 2
    (RFC 894 [15]) or IEEE 802.3 (RFC 1042 [16]) encapsulation if the
    interface is an Ethernet.
    Option value defined as: {"ethernet_encapsulation": True}
    """
    code = 36
    key = "ethernet_encapsulation"

class TCPDefaultTTL(uint8Option):
    """
    Option 37
    Specifies the default TTL that the client should use when sending TCP
    segments.
    Option value defined as: {"tcp_default_ttl": 123}
    """
    code = 37
    key = "tcp_default_ttl"

class TCPKeepaliveInterval(uint32Option):
    """
    Option 38
    Specifies the interval (in seconds) that the client TCP should wait
    before sending a keepalive message on a TCP connection.
    Option value defined as: {"tcp_keepalive_interval": 123}
    """
    code = 38
    key = "tcp_keepalive_interval"

class TCPKeepaliveGarbage(BoolOption):
    """
    Option 39
    Specifies the whether or not the client should send TCP keepalive
    messages with a octet of garbage for compatibility with older
    implementations.
    Option value defined as: {"tcp_keepalive_garbage": True}
    """
    code = 39
    key = "tcp_keepalive_garbage"

class NISDomain(StrOption):
    """
    Option 40
    Specifies the name of the client's NIS [17] domain.
    Option value defined as: {"network_information_service_domain": "google.com"}
    """
    code = 40
    key = "network_information_service_domain"

class NISServer(IPArrayOption):
    """
    Option 41
    Specifies a list of IP addresses indicating NIS servers available to
    the client.
    Option value defined as: {"network_information_servers": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 41
    key = "network_information_servers"

class NTPServers(IPArrayOption):
    """
    Option 42
    Specifies a list of IP addresses indicating NTP [18] servers available
    to the client.
    Option value defined as: {"ntp_servers": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 42
    key = "ntp_servers"

class VendorSpecificInformation(BinOption):
    """
    Option 43
    Super complicated, basically arbitrary data. This option can redefine
    any option other than 0 and 255.
    Option value defined as: {"vender_specific_information": "0x0b 0x1c ..."}
    """
    code = 43
    key = "vendor_specific_information"

class NetbiosNameServer(IPArrayOption):
    """
    Option 44
    Specifies a list of RFC 1001/1002 [19] [20] NBNS name servers listed in
    order of preference.
    Option value defined as: {"netbios_name_servers": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 44
    key = "netbios_name_servers"

class NetbiosDatagramDistributionServer(IPArrayOption):
    """
    Option 45
    Specifies a list of RFC 1001/1002 NBDD servers listed in order of
    preference.
    Option value defined as: {"netbios_datagram_distribution_server": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 45
    key = "netbios_datagram_distribution_server"

class NetbiosNodeType(Option):
    """
    Option 46
    Node type option allows NetBIOS over TCP/IP clients which are
    configurable to be configured as described in RFC 1001/1002.
    Option value defined as: {"netbios_node_type": "B-node"}
    """
    code = 46
    key = "netbios_node_type"
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {
                self.key: {0x1: "B-node", 0x2: "P-node", 0x4: "M-node", 0x8: "H-node"}[
                    int.from_bytes(self.data, "big")
                ]
            }
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        data = {
            "B-node": b"\x01",
            "P-node": b"\x02",
            "M-node": b"\x04",
            "H-node": b"\x08",
        }[value[cls.key]]
        return cls(cls.code, len(data), data)

class NetbiosScope(StrOption):
    """
    Option 47
    Specifies the NetBIOS over TCP/IP scope parameter for the client as
    specified in RFC 1001/1002.
    Option value defined as: {"netbios_scope": "something"}
    """
    code = 47
    key = "netbios_scope"

class NetbiosXWindowSystemFontServer(IPArrayOption):
    """
    Option 48
    Specifies a list of X Window System [21] Font servers available to the
    client.
    Option value defined as: {"netbios_x_window_system_font_servers": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 48
    key = "netbios_x_window_system_font_servers"

class XWindowSystemDisplayManager(IPArrayOption):
    """
    Option 49
    Specifies a list of IP addresses of systems that are running the X
    Window System Display Manager and are available to the client.
    Option value is defined as: {"x_window_system_display_manager": ["1.1.1.1", "2.2.2.2"]}
    """
    code = 49
    key = "x_window_system_display_manager"

class RequestedIPAddress(IPOption):
    """
    Option 50
    This option is used in a client request (DHCPDISCOVER) to allow the
    client to request that a particular IP address be assigned.
    Option value is defined as: {"requested_ip_address": "1.1.1.1"} 
    """
    code = 50
    key = "requested_ip_address"

class IPAddressLeaseTime(uint32Option):
    """
    Option 51
    This option is used in a client request (DHCPDISCOVER or DHCPREQUEST)
    to allow the client to request a lease time for the IP address.  In a
    server reply (DHCPOFFER), a DHCP server uses this option to specify the
    lease time it is willing to offer.
    """
    code = 51
    key = "lease_time"

class Overload(Option):
    """
    Option 52
    This option is used to indicate that the DHCP 'sname' or 'file' fields
    are being overloaded by using them to carry DHCP options. A DHCP server
    inserts this option if the returned parameters will exceed the usual
    space allotted for options.
    """
    code = 52
    key = "option_overload"
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {
                self.key: {
                    1: "'file' field is used to hold options",
                    2: "'sname' field is used to hold options",
                    3: "both fields are used to hold options",
                }[int.from_bytes(self.data, "big")]
            }
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        data = {
            "'file' field is used to hold options": b"\x01",
            "'sname' field is used to hold options": b"\x02",
            "both fields are used to hold options": b"\x03",
        }[value[cls.key]]
        return cls(cls.code, len(data), data)

class MessageType(Option):
    """
    Option 53
    This option is used to convey the type of the DHCP message.
    """
    code = 53
    key = "dhcp_message_type"
    @property
    def value(self) -> Dict[str, str]:
        if self._value is None:
            self._value = {
                self.key: {
                    1: "DHCPDISCOVER",
                    2: "DHCPOFFER",
                    3: "DHCPREQUEST",
                    4: "DHCPDECLINE",
                    5: "DHCPACK",
                    6: "DHCPNAK",
                    7: "DHCPRELEASE",
                    8: "DHCPINFORM",
                }[int.from_bytes(self.data, "big")]
            }
        return self._value
    @classmethod
    def from_value(cls, value: Dict[str, str]):
        data = {
            "DHCPDISCOVER": b"\x01",
            "DHCPOFFER": b"\x02",
            "DHCPREQUEST": b"\x03",
            "DHCPDECLINE": b"\x04",
            "DHCPACK": b"\x05",
            "DHCPNAK": b"\x06",
            "DHCPRELEASE": b"\x07",
            "DHCPINFORM": b"\x08",
        }[value[cls.key]]
        return cls(cls.code, len(data), data)

class ServerIdentifier(IPOption):
    """
    Option 54
    This option is used in DHCPOFFER and DHCPREQUEST messages, and may
    optionally be included in the DHCPACK and DHCPNAK messages.
    """
    code = 54
    key = "dhcp_server"

class ParameterRequestList(uint8ArrayOption):
    """
    Option 55
    This option is used by a DHCP client to request values for specified
    configuration parameters.  The list of requested parameters is
    specified as n octets, where each octet is a valid DHCP option code
    as defined in this document.
    """
    code = 55
    key = "parameter_request_list"

class Message(StrOption):
    """
    Option 56
    This option is used by a DHCP server to provide an error message to a
    DHCP client in a DHCPNAK message in the event of a failure. A client
    may use this option in a DHCPDECLINE message to indicate the why the
    client declined the offered parameters.
    """
    code = 56
    key = "message"

class MaxDHCPMessageSize(uint16Option):
    """
    Option 57
    This option specifies the maximum length DHCP message that it is
    willing to accept.
    """
    code = 57
    key = "max_dhcp_message_size"

class RenewalTime(uint32Option):
    """
    Option 58
    This option specifies the time interval from address assignment until
    the client transitions to the RENEWING state.
    """
    code = 58
    key = "renewal_time"

class RebindingTime(uint32Option):
    """
    Option 59
    This option specifies the time interval from address assignment until
    the client transitions to the REBINDING state.
    """
    code = 59
    key = "rebinding_time"

class VendorClassIdentifier(StrOption):
    """
    Option 60
    This option is used by DHCP clients to optionally identify the vendor
    type and configuration of a DHCP client.
    """
    code = 60
    key = "vendor_class_identifier"

class ClientIdentifier(Option):
    """
    Option 61
    This option is used by DHCP clients to specify their unique
    identifier.  DHCP servers use this value to index their database of
    address bindings.  This value is expected to be unique for all
    clients in an administrative domain.
    """
    code = 61
    key = "client_identifier"
    @property
    def value(self) -> Dict[str, Dict[str, str]]:
        if self._value is None:
            hwtype, hwaddr = struct.unpack(">B6s", self.data)
            self._value = {
                self.key: {
                    "hwtype": hwtype,
                    "hwaddr": ":".join([f"{b:02X}" for b in hwaddr]),
                }
            }
        return self._value
    @classmethod
    def from_value(cls, value):
        hwtype = value[cls.key]["hwtype"]
        hwaddr = value[cls.key]["hwaddr"]
        data = struct.pack(">B", hwtype) + struct.pack(
            ">" + "B" * len(hwaddr.split(":")), *[int(i, 16) for i in hwaddr.split(":")]
        )
        return cls(cls.code, len(data), data)

class NISPlusDomain(StrOption):
    """
    Option 64
    Specifies the name of the client's NIS+ [17] domain.
    """
    code = 64
    key = "nis_plus_domain"

class NISPlusServers(IPArrayOption):
    """
    Option 65
    Specifies a list of IP addresses indicating NIS+ servers available to
    the client.
    """
    code = 65
    key = "nis_plus_servers"

class TFTPServerName(StrOption):
    """
    Option 66
    This option is used to identify a TFTP server when the 'sname' field in
    the DHCP header has been used for DHCP options.
    """
    code = 66
    key = "tftp_server_name"

class BootfileName(StrOption):
    """
    Option 67
    This option is used to identify a bootfile when the 'file' field in the
    DHCP header has been used for DHCP options.
    """
    code = 67
    key = "bootfile_name"

class MobileIPHomeAgent(IPArrayOption):
    """
    Option 68
    Specifies a list of IP addresses indicating mobile IP home agents
    available to the client.
    """
    code = 68
    key = "mobile_ip_home_agent"

class SMTPServer(IPArrayOption):
    """
    Option 69
    Specifies a list of SMTP servers available to the client.
    """
    code = 69
    key = "smtp_servers"

class POP3Server(IPArrayOption):
    """
    Option 70
    Specifies a list of POP3 available to the client.
    """
    code = 70
    key = "pop3_servers"

class NNTPServer(IPArrayOption):
    """
    Option 71
    Specifies a list of NNTP available to the client.
    """
    code = 71
    key = "nntp_servers"

class WWWServer(IPArrayOption):
    """
    Option 72
    Specifies a list of WWW available to the client.
    """
    code = 72
    key = "world_wide_web_servers"

class FingerServer(IPArrayOption):
    """
    Option 73
    Specifies a list of Finger available to the client.
    """
    code = 73
    key = "finger_servers"

class IRCServer(IPArrayOption):
    """
    Option 74
    Specifies a list of IRC available to the client.
    """
    code = 74
    key = "irc_servers"

class StreetTalkServer(IPArrayOption):
    """
    Option 75
    Specifies a list of StreetTalk servers available to the client.
    """
    code = 75
    key = "streettalk_servers"

class StreetTalkDirectoryAssistanceServer(IPArrayOption):
    """
    Option 76
    Specifies a list of STDA servers available to the client.
    """
    code = 76
    key = "stda_servers"

class RelayAgentInformation(StrOption):
    """
    Option 82
    Relay Agent Information
    """
    code = 82
    key = "relay_agent_info"

class UnknownOption(BinOption):
    """
    Represents any options not defined here.
    """
    def __init__(self, code, length, data):
        self.code = code
        self.key = (
            "".join(OPTIONS.get(code, {}).get("name", "Unknown").split()) + f"_{code}"
        )
        super().__init__(code, length, data)

options = OptionDirectory()

VALID_HEX = list(set(string.hexdigits.upper()))

def cur_datetime(us_precision: bool = False) -> str:
    fmt = "%Y-%m-%dT%H:%M:%S" + (".%f" if us_precision else "") + "Z"
    return datetime.datetime.now(datetime.timezone.utc).strftime(fmt)

def cur_timestamp() -> int:
    return int(datetime.datetime.utcnow().timestamp() * 10 ** 9)

def visual_length(text: str) -> int:
    """
    Given a string it returns the visual length of the string as opposed to the
    len function which returns the number of printable characters.
    """
    # See https://www.unicode.org/reports/tr11/ for how this dict in constructed
    visual_len = {
        "F": 1,
        "H": 1,
        "Na": 1,
        "N": 1,
        "W": 2,
        "A": 2,
    }
    return sum([visual_len[unicodedata.east_asian_width(char)] for char in text]) + 1

def random_mac(num_bytes: int = 6, delimiter: str = ":") -> str:
    """
    Generates an 6 byte long MAC address.
    >>> random_mac()
    'CC:AC:3C:85:A4:EF'
    """
    return delimiter.join(
        ["".join(random.choices(VALID_HEX, k=2)) for i in range(num_bytes)]
    )

def is_mac_addr(mac_addr: str) -> bool:
    """
    Returns True if the string is a valid MAC address.
    Accepts ":" or "-" as valid MAC address delimiters.
    """
    mac_addr = mac_addr.upper()
    delimiter = ":" if ":" in mac_addr else "-"
    if len(mac_addr.split(delimiter)) != 6 or len(mac_addr) != 17:
        return False
    if any([b not in VALID_HEX for b in "".join(mac_addr.split(delimiter))]):
        return False
    return True

mac_vendor_map: Dict[str, str] = {
    line.split("\t\t")[0].split(" ")[0]: line.split("\t\t")[1]
    for line in [
        line.strip()
        for line in open(r"files\oui.txt", encoding='utf-8').readlines()
        if "(base 16)" in line
    ]
}

def mac2vendor(mac_addr: str) -> str:
    if is_mac_addr(mac_addr):
        return mac_vendor_map.get(
            mac_addr.replace(":", "").replace("-", "")[:6].upper(),
            "Unknown Manufacturer",
        )
    else:
        raise ValueError(f"{mac_addr} is not a valid MAC address")

def get_ip_by_iface(iface: str) -> str:
    rand_port = 61224
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setsockopt(socket.SOL_SOCKET, 25, iface.encode())
    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    s.connect(("255.255.255.255", rand_port))
    return s.getsockname()[0]

def get_ip_by_server(server: str) -> str:
    rand_port = 61222
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect((server, rand_port))
    return s.getsockname()[0]

OPTIONS_INTERFACE = options

@dataclass
class DHCPPacket(object):
    """
    This class models a DHCP packet. From RFC 2131:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
    +---------------+---------------+---------------+---------------+
    |                            xid (4)                            |
    +-------------------------------+-------------------------------+
    |           secs (2)            |           flags (2)           |
    +-------------------------------+-------------------------------+
    |                          ciaddr  (4)                          |
    +---------------------------------------------------------------+
    |                          yiaddr  (4)                          |
    +---------------------------------------------------------------+
    |                          siaddr  (4)                          |
    +---------------------------------------------------------------+
    |                          giaddr  (4)                          |
    +---------------------------------------------------------------+
    |                                                               |
    |                          chaddr  (16)                         |
    |                                                               |
    |                                                               |
    +---------------------------------------------------------------+
    |                                                               |
    |                          sname   (64)                         |
    +---------------------------------------------------------------+
    |                                                               |
    |                          file    (128)                        |
    +---------------------------------------------------------------+
    |                                                               |
    |                          options (variable)                   |
    +---------------------------------------------------------------+
    """
    op: str  # 1 octet - Message Type: 1 is a BOOTREQUEST, 2 is a BOOTREPLY
    htype: str  # 1 octet - Hardware Type: 1 for 10mb ethernet
    hlen: int  # 1 octet - Hardware Address Length: 6 for 10mb ethernet
    hops: int  # 1 octet - Hops: clients should set this to 0, may be used by relay
    xid: int  # 4 octets - Transaction ID: random number, maintained for entire tx
    secs: int  # 2 octets - Seconds: number of seconds since addr process began
    flags: int  # 2 octets - Flags: bits 1-15 reserved, bit 0 indicates whether to use broadcast
    ciaddr: ipaddress.IPv4Address  # 4 octets - Client Address: filled in if client can respond to ARP
    yiaddr: ipaddress.IPv4Address  # 4 octets - 'your' (client) IP address
    siaddr: ipaddress.IPv4Address  # 4 octets - Next Server: IP of next server to use for bootstrap (OFFER/ACK)
    giaddr: ipaddress.IPv4Address  # 4 octets - Relay Agent: relay IP
    chaddr: str  # 16 octets - Client Hardware Addr: MAC addr of client (usually len 6 + 10 padding)
    sname: bytes  # 64 octets - Server Name: optional, host name, null terminated
    file: bytes  # 128 octets - File Name: Null terminated str, boot file name
    options: OptionList  # N octets - Options Field: variable length, options section started by the DHCP
    magic_cookie: ClassVar[bytes] = b"\x63\x82\x53\x63"
    cookie_offset_start: ClassVar[int] = 236
    cookie_offset_end: ClassVar[int] = 240
    packet_fmt: ClassVar[str] = "!BBBBLHHLLLL16s64s128s"
    op_map: ClassVar[Dict[int, str]] = {1: "BOOTREQUEST", 2: "BOOTREPLY"}
    inverse_op_map: ClassVar[Dict[str, int]] = {v: k for k, v in op_map.items()}
    htype_map: ClassVar[Dict[int, str]] = {
        1: "ETHERNET",
        2: "EXPERIMENTAL",
        3: "AMATEUR",
        4: "PROTEON",
        5: "CHAOS",
        6: "IEEE",
        7: "ARCNET",
        8: "HYPERCHANNEL",
        9: "LANSTAR",
    }
    inverse_htype_map: ClassVar[Dict[str, int]] = {v: k for k, v in htype_map.items()}
    @property
    def asbytes(self):
        str2bin = lambda s: bytes([int(i, 16) for i in s.split(":")])
        packet_head = [
            self.inverse_op_map[self.op.upper()],
            self.inverse_htype_map[self.htype.upper()],
            self.hlen,
            self.hops,
            self.xid,
            self.secs,
            self.flags,
            int(self.ciaddr),
            int(self.yiaddr),
            int(self.siaddr),
            int(self.giaddr),
            str2bin(self.chaddr).ljust(16, b"\x00"),
            self.sname.ljust(64, b"\x00"),
            self.file.ljust(128, b"\x00"),
        ]
        encoded_packet = struct.pack(self.packet_fmt, *packet_head)
        encoded_packet += self.magic_cookie
        for option in self.options:
            encoded_packet += option.asbytes
        if encoded_packet[-1] != 255:
            encoded_packet += b"\xff"
        return encoded_packet
    @property
    def msg_type(self) -> Optional[str]:
        msg_type_option = self.options.by_code(53)
        if msg_type_option:
            return list(msg_type_option.value.values())[0]
        else:
            return None
    @classmethod
    def from_bytes(cls, packet: bytes):
        """
        Given a DHCP packet in bytes / wire format return a DHCPPacket object.
        """
        if packet[cls.cookie_offset_start : cls.cookie_offset_end] != cls.magic_cookie:
            raise MalformedPacketError("Magic cookie missing")
        try:
            decoded_packet = [
                field.rstrip(b"\x00") if isinstance(field, bytes) else field
                for field in struct.unpack(
                    cls.packet_fmt, packet[: cls.cookie_offset_start]
                )
            ]
        except:
            raise MalformedPacketError("Unable to parse DHCP packet")
        options_list = OptionList()
        read_pos = cls.cookie_offset_end
        code = 0
        while read_pos < len(packet) and code != 255:
            code = packet[read_pos]
            if code in [0, 255]:
                data_read_size = 1
            else:
                length = packet[read_pos + 1]
                data_read_size = 1 + 1 + length
            option_bytes = packet[read_pos : read_pos + data_read_size]
            options_object = OPTIONS_INTERFACE.bytes_to_object(option_bytes)
            options_list.append(options_object)
            read_pos += data_read_size
        decoded_packet.append(options_list)
        # Decode the op code
        decoded_packet[0] = cls.op_map[decoded_packet[0]]
        # Decode hardware type
        decoded_packet[1] = cls.htype_map[decoded_packet[1]]
        # Convert the ciaddr, yiaddr, siaddr, and giaddr into python IP objects
        decoded_packet[7:11] = [
            ipaddress.IPv4Address(field) for field in decoded_packet[7:11]
        ]
        # Convert MAC addr into bin string
        decoded_packet[11] = decoded_packet[11].ljust(6, b"\x00")
        bin2str = lambda b: ":".join([f"{i:02X}" for i in b])
        decoded_packet[11] = bin2str(decoded_packet[11])
        return cls(*decoded_packet)
    def format_options(self, opt_str, line_divider, line_len):
        """
        Given a string with all the options in a packet this will format
        the string into an ASCII table format.
        """
        line_pos = 0
        output = ""
        new_line = "|\n" + line_divider + "|"
        skip_next_space = False  # Need this for alignment
        last_char = ""
        for char in opt_str:
            if char == " " and skip_next_space:
                skip_next_space = False
                continue
            char = " " if last_char == "|" and char == "|" else char
            output += char
            line_pos = (line_pos + 1) % line_len
            if line_pos == 0:
                output += new_line
                skip_next_space = True
            last_char = output[-1]
        return output
    def view_packet(self):
        """
        A fun way of visualising the DHCP packet in ASCII table format.
        """
        bytes_per_line = 4
        byte_len = 15
        spacing = lambda num_bytes: (num_bytes * byte_len) + num_bytes - 1
        column = (
            lambda str_to_space, num_bytes: f"{str_to_space[:spacing(num_bytes)].center(spacing(num_bytes))}|"
        )
        line = "+" + ("-" * (byte_len * bytes_per_line + bytes_per_line))[:-1] + "+\n"
        base_packet = (
            "0                   1                   2                   3    \n"
            "0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \n"
            "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
            "|"
            + column(f"{self.op} (1)", 1)
            + column(f"{self.htype} (1)", 1)
            + column(f"len {self.hlen} (1)", 1)
            + column(f"{self.hops} hops (1)", 1)
            + "\n"
            "+---------------+---------------+---------------+---------------+\n"
            "|" + column(f"xid=0x{self.xid:08X} (4)", 4) + "\n"
            "+-------------------------------+-------------------------------+\n"
            "|"
            + f"{self.secs} secs (2)".center(spacing(2))
            + "|"
            + f"{'BROADCAST' if self.flags else 'UNICAST'} (2)".center(spacing(2))
            + "|\n"
            "+-------------------------------+-------------------------------+\n"
            "|" + column(f"client addr: {self.ciaddr!s} (4)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|" + column(f"your addr: {self.yiaddr!s} (4)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|" + column(f"next server: {self.siaddr!s} (4)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|" + column(f"relay: {self.giaddr!s} (4)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|                                                               |\n"
            "|" + column(f"client mac: {self.chaddr}  (16)", 4) + "\n"
            "|                                                               |\n"
            "|                                                               |\n"
            "+---------------------------------------------------------------+\n"
            "|                                                               |\n"
            "|" + column(f"server name: {self.sname}   (64)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|                                                               |\n"
            "|" + column(f"boot file: {self.file} (128)", 4) + "\n"
            "+---------------------------------------------------------------+\n"
            "|"
            + column(
                f"magic cookie: {hex(int.from_bytes(self.magic_cookie, 'big'))}",
                len(self.magic_cookie),
            )
            + "\n"
            "+---------------------------------------------------------------+\n"
        )
        base_packet += "|"
        opt_str = ""
        for opt in self.options:
            opt_str += column(f"code={opt.code} (1)", 1)
            if opt.code not in [0, 255]:
                opt_str += column(f"len={opt.length} (1)", 1)
                if opt.code == 53:
                    # Shortening DHCP msg type for display -- special case
                    opt_str += column(
                        f"{opt.value[opt.key]} ({opt.length})", opt.length
                    )
                else:
                    opt_str += column(
                        f"{opt.key} {opt.value[opt.key]} ({opt.length})", opt.length
                    )
        base_packet += self.format_options(opt_str, line, spacing(bytes_per_line))
        base_packet += "\n" + line[: len(base_packet.split("\n")[-1])]
        base_packet = base_packet[:-1] + "+"
        return base_packet
    @classmethod
    def Discover(
        cls,
        mac_addr: str,
        seconds: int = 0,
        tx_id: Optional[int] = None,
        use_broadcast: bool = True,
        relay: Optional[str] = None,
        option_list: Optional[OptionList] = None,
    ):
        """
        Convenient constructor for a DHCP discover packet.
        """
        if not is_mac_addr(mac_addr):
            raise DHCPValueError(
                "MAC address must consist of 6 octets delimited by ':'"
            )
        option_list = option_list if option_list else OptionList()
        option_list.insert(0, options.short_value_to_object(53, "DHCPDISCOVER"))
        relay_ip = ipaddress.IPv4Address(relay or 0)
        return cls(
            "BOOTREQUEST",
            cls.htype_map[1],  # 10 mb ethernet
            6,  # 6 byte hardware addr
            0,  # clients should set this to 0
            tx_id or random.getrandbits(32),
            seconds,
            0b1000_0000_0000_0000 if use_broadcast else 0,
            ipaddress.IPv4Address(0),  # Must be 0
            ipaddress.IPv4Address(0),
            ipaddress.IPv4Address(0),
            relay_ip,
            mac_addr,
            b"",
            b"",
            option_list,
        )
    @classmethod
    def Offer(
        cls,
        mac_addr: str,
        seconds: int,
        tx_id: int,
        yiaddr: Union[int, str],
        use_broadcast: bool = True,
        relay: Optional[str] = None,
        sname: bytes = b"",
        fname: bytes = b"",
        option_list: Optional[OptionList] = None,
    ):
        """
        Convenient constructor for a DHCP offer packet.
        """
        if len(mac_addr.split(":")) != 6 or len(mac_addr) != 17:
            raise DHCPValueError(
                "MAC address must consist of 6 octets delimited by ':'"
            )
        option_list = option_list if option_list else OptionList()
        option_list.insert(0, options.short_value_to_object(53, "DHCPOFFER"))
        relay_ip = ipaddress.IPv4Address(relay or 0)
        return cls(
            "BOOTREPLY",
            cls.htype_map[1],  # 10 mb ethernet
            6,  # 6 byte hardware addr
            0,  # clients should set this to 0
            tx_id,
            seconds,
            0b1000_0000_0000_0000 if use_broadcast else 0,
            ipaddress.IPv4Address(0),
            # yiaddr - "your address", address being proposed by server
            ipaddress.IPv4Address(yiaddr),
            ipaddress.IPv4Address(0),
            relay_ip,
            mac_addr,
            sname,
            fname,
            option_list,
        )
    @classmethod
    def Request(
        cls,
        mac_addr: str,
        seconds: int,
        tx_id: int,
        use_broadcast: bool = True,
        relay: Optional[str] = None,
        sname: bytes = b"",
        fname: bytes = b"",
        client_ip=ipaddress.IPv4Address(0),
        option_list: Optional[OptionList] = None,
    ):
        """
        Convenient constructor for a DHCP request packet.
        """
        if len(mac_addr.split(":")) != 6 or len(mac_addr) != 17:
            raise DHCPValueError(
                "MAC address must consist of 6 octets delimited by ':'"
            )
        option_list = option_list if option_list else OptionList()
        option_list.insert(0, options.short_value_to_object(53, "DHCPREQUEST"))
        relay_ip = ipaddress.IPv4Address(relay or 0)
        return cls(
            "BOOTREQUEST",
            cls.htype_map[1],  # 10 mb ethernet
            6,  # 6 byte hardware addr
            0,  # clients should set this to 0
            tx_id,
            seconds,
            0b1000_0000_0000_0000 if use_broadcast else 0,
            client_ip,
            ipaddress.IPv4Address(0),
            ipaddress.IPv4Address(0),
            relay_ip,
            mac_addr,
            sname,
            fname,
            option_list,
        )
    @classmethod
    def Ack(
        cls,
        mac_addr: str,
        seconds: int,
        tx_id: int,
        yiaddr: Union[int, str],
        use_broadcast: bool = True,
        relay: Optional[str] = None,
        sname: bytes = b"",
        fname: bytes = b"",
        option_list: Optional[OptionList] = None,
    ):
        """
        Convenient constructor for a DHCP ack packet.
        """
        # Can be refactored to just use the Request constructor if it turns out that Ack has no special needs.
        if len(mac_addr.split(":")) != 6 or len(mac_addr) != 17:
            raise DHCPValueError(
                "MAC address must consist of 6 octets delimited by ':'"
            )
        option_list = option_list if option_list else OptionList()
        option_list.insert(0, options.short_value_to_object(53, "DHCPACK"))
        relay_ip = ipaddress.IPv4Address(relay or 0)
        return cls(
            "BOOTREPLY",
            cls.htype_map[1],  # 10 mb ethernet
            6,  # 6 byte hardware addr
            0,  # clients should set this to 0
            tx_id,
            seconds,
            0b1000_0000_0000_0000 if use_broadcast else 0,
            ipaddress.IPv4Address(0),
            # yiaddr - "your address", address being proposed by server
            ipaddress.IPv4Address(yiaddr),
            ipaddress.IPv4Address(0),
            relay_ip,
            mac_addr,
            sname,
            fname,
            option_list,
        )